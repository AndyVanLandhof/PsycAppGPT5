/**
 * Evaluate synthetic OCR H573/01 Philosophy of Religion questions
 * against real past-paper style using Claude (or another Anthropic model).
 *
 * Usage:
 *   node scripts/run-question-eval-ocr-phil.cjs
 *
 * Inputs:
 *   - public/exam-eval/ocr-h573-phil_synthetic-questions.json
 *   - 666950-question-paper-philosophy-of-religion_extracted.txt (real QP)
 *
 * Output:
 *   - public/exam-eval/ocr-h573-phil_question-report.json
 */

require('dotenv').config();
const fs = require('fs');
const path = require('path');

const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;
const ANTHROPIC_MODEL = process.env.ANTHROPIC_MODEL || 'claude-3-7-sonnet-20250219';

if (!ANTHROPIC_API_KEY) {
  console.error('‚ùå ANTHROPIC_API_KEY is not set in .env ‚Äì cannot run question eval.');
  process.exit(1);
}

const ROOT = path.join(__dirname, '..');
const SYNTH_FILE = path.join(ROOT, 'public', 'exam-eval', 'ocr-h573-phil_synthetic-questions.json');
const QP_PATH = path.join(
  ROOT,
  'public',
  'vault',
  'ocr-rs',
  'vault',
  'PastPapers',
  'Religious Studies',
  '666950-question-paper-philosophy-of-religion_extracted.txt'
);
const REPORT_FILE = path.join(ROOT, 'public', 'exam-eval', 'ocr-h573-phil_question-report.json');

function readJson(file) {
  return JSON.parse(fs.readFileSync(file, 'utf8'));
}

function readText(file) {
  return fs.readFileSync(file, 'utf8');
}

function extractRealQuestionStems(qpText, maxChars = 8000) {
  const lines = qpText.split('\n');
  const stems = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const m = line.match(/^(\d+)\*\s+(.+)/);
    if (!m) continue;
    const number = m[1];
    const parts = [m[2].trim()];
    let j = i + 1;
    while (j < lines.length && !/\[40\]/.test(lines[j])) {
      const t = lines[j].trim();
      if (t) parts.push(t);
      j++;
    }
    stems.push(`Q${number}: ${parts.join(' ')}`);
    i = j;
  }

  let buf = stems.join('\n\n');
  if (buf.length > maxChars) {
    buf = buf.slice(0, maxChars);
  }
  return buf;
}

async function callAnthropic(prompt) {
  const res = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': ANTHROPIC_API_KEY,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({
      model: ANTHROPIC_MODEL,
      max_tokens: 900,
      temperature: 0.2,
      messages: [
        {
          role: 'user',
          content: prompt
        }
      ]
    })
  });

  if (!res.ok) {
    const body = await res.text();
    throw new Error(`Anthropic error ${res.status}: ${body}`);
  }

  const data = await res.json();
  const text = (data.content && data.content[0] && data.content[0].text) || '';
  try {
    return JSON.parse(text);
  } catch {
    const match = text.match(/\{[\s\S]*\}/);
    if (match) return JSON.parse(match[0]);
    throw new Error(`Failed to parse JSON from Anthropic response: ${text.slice(0, 200)}...`);
  }
}

function buildEvalPrompt(realStems, q) {
  return `
You are a senior OCR A Level Religious Studies question-setting advisor for:
  Specification: H573
  Component: H573/01 ‚Äì Philosophy of Religion

You will be shown:
- A set of REAL past-paper question stems from H573/01 (for style reference).
- ONE SYNTHETIC QUESTION that has been generated by an AI.

Your job is to judge whether the SYNTHETIC QUESTION is:
- On-spec (fits the H573/01 Philosophy of Religion content and AO expectations).
- Stylistically consistent with OCR H573/01 40-mark essays.
- Appropriately weighted in marks and command word.
- Roughly in the right difficulty band (too easy / typical / too hard).

REAL OCR QUESTION STEMS (for style reference ‚Äì do NOT copy):
${realStems}

NOW EVALUATE THIS SYNTHETIC QUESTION:

ID: ${q.id}
Topic area: ${q.topicArea || '(unspecified)'}
Sub-area: ${q.subArea || '(unspecified)'}
Command word: ${q.commandWord || '(unspecified)'}
Marks: ${q.marks}

TEXT:
${q.text}

Using your knowledge of OCR H573/01 Philosophy of Religion and the examples above,
answer the following in STRICT JSON:
{
  "onSpec": true,
  "specTopicGuess": "Short description of the likely spec bullet(s) this targets",
  "commandWordOk": true,
  "marksAppropriate": true,
  "styleMatchScore": 0.0,
  "difficultyBand": "too easy | typical | too hard",
  "tooSimilarToReal": false,
  "closestRealQuestionStyle": "Very short description comparing to one of the real stems above",
  "issues": [
    "Any concrete problems (e.g. off-spec content, odd AO balance, vague wording, almost duplicate of a real question)"
  ],
  "overallComment": "2‚Äì3 sentence plain-English verdict on whether this would be acceptable as a real OCR H573/01 question."
}

Guidance:
- styleMatchScore is a number between 0.0 and 1.0 where 1.0 = indistinguishable in style from real OCR questions.
- "onSpec" should be false if the content is clearly outside OCR H573/01 or badly mixes topics in an unrealistic way.
- "tooSimilarToReal" should be true if the synthetic question is effectively a paraphrase of one of the real stems.
`;
}

async function main() {
  console.log('üîé Evaluating synthetic OCR H573/01 Philosophy questions...');
  console.log('  Synthetic file :', SYNTH_FILE);
  console.log('  Real QP        :', QP_PATH);

  const synth = readJson(SYNTH_FILE);
  const qpText = readText(QP_PATH);
  const realStems = extractRealQuestionStems(qpText);

  const questions = synth.questions || [];
  if (!questions.length) {
    console.error('‚ùå No questions found in synthetic file.');
    process.exit(1);
  }

  const results = [];

  for (const q of questions) {
    console.log(`\nüß™ Evaluating synthetic question ${q.id || '(no id)'}...`);
    const prompt = buildEvalPrompt(realStems, q);
    try {
      const evalJson = await callAnthropic(prompt);
      results.push({
        id: q.id,
        topicArea: q.topicArea,
        subArea: q.subArea,
        commandWord: q.commandWord,
        marks: q.marks,
        text: q.text,
        eval: evalJson
      });
      console.log(
        `   -> onSpec: ${evalJson.onSpec}, styleMatch: ${evalJson.styleMatchScore}, difficulty: ${evalJson.difficultyBand}`
      );
    } catch (e) {
      console.error('   ‚ùå Error evaluating question:', e.message);
      results.push({
        id: q.id,
        topicArea: q.topicArea,
        subArea: q.subArea,
        commandWord: q.commandWord,
        marks: q.marks,
        text: q.text,
        error: e.message
      });
    }
  }

  // Aggregate summary
  const summary = {
    spec: synth.spec || 'OCR H573/01 Philosophy of Religion',
    model: ANTHROPIC_MODEL,
    totalQuestions: results.length,
    counts: {
      onSpec: 0,
      offSpec: 0,
      tooSimilar: 0
    },
    styleMatch: {
      mean: null
    }
  };

  let styleSum = 0;
  let styleCount = 0;

  for (const r of results) {
    if (r.eval) {
      if (r.eval.onSpec) summary.counts.onSpec += 1;
      else summary.counts.offSpec += 1;
      if (r.eval.tooSimilarToReal) summary.counts.tooSimilar += 1;
      if (typeof r.eval.styleMatchScore === 'number') {
        styleSum += r.eval.styleMatchScore;
        styleCount += 1;
      }
    }
  }

  if (styleCount > 0) {
    summary.styleMatch.mean = styleSum / styleCount;
  }

  fs.mkdirSync(path.dirname(REPORT_FILE), { recursive: true });
  fs.writeFileSync(
    REPORT_FILE,
    JSON.stringify(
      {
        summary,
        results
      },
      null,
      2
    ),
    'utf8'
  );

  console.log('\n‚úÖ Question eval report written to:', REPORT_FILE);
  console.log('   On-spec questions:', summary.counts.onSpec);
  console.log('   Off-spec questions:', summary.counts.offSpec);
  console.log('   Too-similar-to-real questions:', summary.counts.tooSimilar);
  if (summary.styleMatch.mean != null) {
    console.log('   Mean styleMatchScore:', summary.styleMatch.mean.toFixed(3));
  }
}

main().catch((err) => {
  console.error('‚ùå Failed to run question eval:', err.message);
  process.exit(1);
});


